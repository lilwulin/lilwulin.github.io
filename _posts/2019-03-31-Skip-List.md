---
layout: post
title: 概率游戏：Skip Lists 跳跃表
categories: blog
---

和红黑树、AVL树、B+树相比，**跳跃表（Skip List）**算是一个比较年轻的数据结构，它允许我们以平均 *O(Log N)* 的复杂度进行增删查改。由于跳跃表实现起来比B+树要简单，并发性能比B+树要好，因此也常常代替B+树成为一些内存数据库（比如Redis、MemSQL）的平衡树。在这篇博文里，我们一起学习一下什么是跳跃表，它如何进行增删查改，以及它和B+树的对比。

# 1. 跳跃表的结构
既然是一条List，跳跃表肯定是由节点组成的。一颗跳跃表节点的简化结构如下图所示：
{% include image.html url="/images/SkipListNode.png" desc="图 1: 跳跃表节点" %}

一颗节点包括要记录的值，也就是图中的 **Value**；还有多层指针，也就是图中标识的 **Leve 1** 到 **Level N**；每层指针会指向下一颗节点或者为空。各个节点相连，由头到尾，值的排列从小到大，就组成了一张完整的跳跃表。现在假设有一张跳跃表，存储了四个整型元素，分别是1，4，16，43；我们可以画出简化版的跳跃表结构：
{% include image.html url="/images/SkipList.png" desc="图 2: 跳跃表结构" %}

可以看到，表头节点不包含任何元素，它是我们搜索的起点；每一颗节点都有不同的层次，每一层指针都指向下一颗拥有相同层的节点，或者为空。这样的结构意味着我们搜索某个元素的时候可以“抄近道”：比如我们要搜索43时，可以通过表头的 L6 直接跳到值为43的节点，而不需要经过1，4，和16。

那么问题来了，图中每颗节点的层数都不一样，那一颗节点应该有多少层？答案是**由概率决定**。当一颗节点被新创建时，它的层数是随机的，之后都不会更改。这个特性使得跳跃表的维护成本比B+树要低的多，不需要做节点的聚合和分裂操作，但同样可以得到和B+树相同的查询性能。

跳跃表的平均查询复杂度能达到O(Log N)，原因藏在层数的概率分布设计上。节点层数符合**幂律(Power Law)分布**。也就是说层数越高，出现的概率越小。为什么不是均匀分布或者正态分布，而是幂律分布？这样设计是为了有效地切割搜索空间。不太严谨地解释，就是我们希望在平均情况下，有某颗层数为 **M** 的元素能够切掉一半的搜索空间，然后在一半的搜索空间里面，又有一个层数为 **M-1** 的元素再切掉一半的搜索空间，达到分而治之的效果。只有幂等分布能够符合我们这样的要求。

层数的选择听起来复杂，其实实现起来很简单，参照论文可以写出下面的伪代码：
```python
randomLevel():
    level = 1
    # random()返回一个[0..1)之间的随机数
    while random() < p and level < MAX_LEVEL do:
        level := leve + 1
    return level
```
实现中，概率阈值 *p* 可以选择0.5，不同的值对性能可能稍有影响；最大层高 *MAX_LEVEL* 可以选择为32。

# 2. 跳跃表的读和写
## 2.1 查询
从 *图 2* 的结构我们很容易可以看出，查找一个节点时，我们应该尽可能地待在高层，一直往右走，因为层次越高，分割的搜索空间就越大，我们需要做的查询操作就越少；直到无路可走时，再往下走，如果已经达到最底层了，那下一个元素只能是我们要找的目标或者不存在。根据 *图 2*，假如我们要寻找值为16的节点，可以用红色箭头标出搜索路径，如下图所示：
{% include image.html url="/images/SkipListSearch.png" desc="图 3: 跳跃表查询" %}

## 2.2 插入
当进行插入操作时，我们第一步还是要进行查询；由于跳跃表不像链表一样每个节点只指向单个节点，我们需要临时存储沿途的查询路径，这样才能快速地将原有的一些节点重新指向新节点。论文里给出了一个方法，那就是使用一个大小为MAX_LEVEL的临时数组，它的下标对应着层高；每一个数组元素存储着沿途查询时最新出现的、层高和下标相同的跳跃表节点（为了方便，我们假设下标从1开始）。由于MAX_LEVEL不是一个很大的数，因此临时数组开销和一个大的跳跃表相比可以说是微乎其微。听起来有点绕，我们不妨结合着图来看，下图假设我们要往原有的跳跃表插入一个值为32的节点，它随机生成的层高为5：
{% include image.html url="/images/SkipListInsert.png" desc="图 4: 跳跃表插入节点" %}

# 3. 跳跃表 vs. B+树
和B+树相比，跳跃表有几个好处：
1. 实现简单；跳跃表进行插入和删除操作时不需要维护节点的分裂和合并，比B+树要容易实现很多；
2. 内存压力小；和上一条理由一样，B+树进行节点分裂和合并时对内存读写较为密集；
3. 并发性能好；我们可以举插入新数据为例子，在要用到锁的情况下，跳跃表只需要对指向新节点的几个节点加写锁，粒度较小；而B+树沿途检索下来，有可能会对一大片节点加了写锁，而且B+树的节点和跳跃表的节点不同，有可能存储着多个元素。当然，B+树有很多针对并发写的优化，但是因为B+树自身结构的原因，都没有跳跃表来的简单，更何况还存在[无锁的跳跃表实现](http://www.cse.yorku.ca/~ruppert/papers/lfll.pdf)。

那么说了那么多跳跃表的优点和B+树的缺点，跳跃表是否可以完全取代B+树了呢？答案是否定的。一般来说硬盘型数据库（比如MySQL）的存储引擎对数据的组织都是以硬盘的页（大小以KB计）为单位，再映射到内存的。我们回忆一下B+树的结构，如下图：
{% include image.html url="/images/BpTree.png" desc="图 5: B+树结构" %}

每个B+树节点都可以对应到硬盘上的一个页，每个页都是元素的聚合。B+树的结构天生就很容易存储这种聚合的数据，而跳跃表每个节点都只单独存储一个元素，很难进行这种内存到硬盘的映射。也正是因为这样，跳跃表总是多见于MemSQL、Redis这种内存型数据库，或者HBase的内存存储，但是很多硬盘型数据库，仍然主要使用B+树作为自己的索引。

# 4. 总结
在本篇博文，我们一起学习了跳跃表、它如何进行读写、以及它和B+树的对比。跳跃表简单易懂，而且并发效率高，是很多内存数据库平衡树的替代品；但是它也不是万能的，它不能像B+树那样将内存和硬盘很好地结合起来，因此我们也要结合自己的实际业务出发，如果数据只是存储在内存中，跳跃表是个不错的索引选择。

# 引用材料
1. Redis作者 antirez [关于 Skip List 的讨论](https://news.ycombinator.com/item?id=1171423)
2. MemSQL CTO Adam Prout [对 Skip List 的介绍](https://www.memsql.com/blog/what-is-skiplist-why-skiplist-index-for-memsql/)
3. 《Redis设计与实现》（黄建宏著）[关于 Skip List 实现的章节](http://redisbook.com/preview/skiplist/datastruct.html)
4. Skip List最初的发明论文 [Skip Lists: A Probabilistic Alternative to Balanced Trees](https://www.epaperpress.com/sortsearch/download/skiplist.pdf)